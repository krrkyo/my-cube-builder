<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Cube Builder</title>
    <!-- Google Material Symbols Link -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* Material Design 3 inspired color variables */
        :root {
            --md-sys-color-primary: #6750A4;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #EADDFF;
            --md-sys-color-on-primary-container: #21005D;

            --md-sys-color-secondary: #625B71;
            --md-sys-color-on-secondary: #FFFFFF;
            --md-sys-color-secondary-container: #E8DEF8;
            --md-sys-color-on-secondary-container: #1D192B;

            --md-sys-color-tertiary: #7D5260;
            --md-sys-color-on-tertiary: #FFFFFF;
            --md-sys-color-tertiary-container: #FFD8E4;
            --md-sys-color-on-tertiary-container: #31111D;

            --md-sys-color-error: #B3261E;
            --md-sys-color-on-error: #FFFFFF;
            --md-sys-color-error-container: #F9DEDC;
            --md-sys-color-on-error-container: #410E0B;

            --md-sys-color-background: #FFFBFE;
            --md-sys-color-on-background: #1C1B1F;
            --md-sys-color-surface: #FFFBFE;
            --md-sys-color-on-surface: #1C1B1F;
            --md-sys-color-surface-variant: #E7E0EC;
            --md-sys-color-on-surface-variant: #49454F;
            --md-sys-color-outline: #79747E;

            --md-sys-color-add-mode: #4CAF50; /* Green for add */
            --md-sys-color-remove-mode: #f44336; /* Red for remove */
            --md-sys-color-utility: #607d8b; /* Greyish blue for utility */
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: var(--md-sys-color-background);
            color: var(--md-sys-color-on-background);
        }

        #info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--md-sys-color-surface-variant);
            color: var(--md-sys-color-on-surface-variant);
            padding: 12px 20px;
            border-radius: 12px; /* More rounded */
            font-size: 0.95em;
            z-index: 10;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08); /* Softer shadow */
            transition: opacity 0.3s ease-in-out;
        }
        #info.hidden {
            opacity: 0;
            pointer-events: none;
            display: none;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
        }

        button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px; /* Space between icon and text */
            padding: 12px 20px;
            font-size: 1.05em;
            cursor: pointer;
            border: none;
            border-radius: 20px; /* MD3 rounded corners */
            color: var(--md-sys-color-on-primary);
            background-color: var(--md-sys-color-primary); /* Default primary button */
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23); /* Elevated button shadow */
            transition: all 0.2s cubic-bezier(0.4, 0.0, 0.2, 1); /* MD3 motion */
        }
        button:hover {
            background-color: color-mix(in srgb, var(--md-sys-color-primary) 85%, black); /* Darken slightly on hover */
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2), 0 6px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }
        button:active {
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            transform: translateY(1px);
        }

        /* Specific button colors */
        button#addModeBtn {
            background-color: var(--md-sys-color-add-mode);
        }
        button#addModeBtn:hover {
            background-color: color-mix(in srgb, var(--md-sys-color-add-mode) 85%, black);
        }
        button#removeModeBtn {
            background-color: var(--md-sys-color-remove-mode);
        }
        button#removeModeBtn:hover {
            background-color: color-mix(in srgb, var(--md-sys-color-remove-mode) 85%, black);
        }
        button.annotate-btn, button.toggle-info {
            background-color: var(--md-sys-color-utility);
        }
        button.annotate-btn:hover, button.toggle-info:hover {
            background-color: color-mix(in srgb, var(--md-sys-color-utility) 85%, black);
        }

        /* Active mode styling */
        button.active {
            outline: 3px solid var(--md-sys-color-primary-container); /* MD3 focus ring style */
            outline-offset: 3px;
            box-shadow: 0 0 0 6px var(--md-sys-color-primary-container); /* Add a subtle glow for active */
            transform: translateY(0); /* Ensure no lift when active */
        }
        button#addModeBtn.active {
             outline-color: var(--md-sys-color-add-mode);
             box-shadow: 0 0 0 3px var(--md-sys-color-add-mode), 0 3px 6px rgba(0,0,0,0.16);
        }
        button#removeModeBtn.active {
             outline-color: var(--md-sys-color-remove-mode);
             box-shadow: 0 0 0 3px var(--md-sys-color-remove-mode), 0 3px 6px rgba(0,0,0,0.16);
        }


        canvas {
            display: block;
            width: 100%;
            height: 100%;
            flex-grow: 1;
        }

        /* Annotation Overlay Styles */
        #annotationOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center; /* Centered canvas vertically */
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            position: relative; /* Set as positioning context for absolute children */
        }
        #annotationOverlay.hidden {
            display: none;
        }
        #canvasContainer {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--md-sys-color-surface-variant); /* Fallback if screenshot doesn't load */
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 12px; /* MD3 rounded corners for container */
            overflow: auto; /* Allow scrolling if image is larger than viewport */
            min-width: 100px;
            min-height: 100px;
            margin-top: auto; /* Pushes canvas down to make space for tools if needed */
            margin-bottom: auto; /* Pushes canvas up to make space for tools if needed */
        }
        #screenshotCanvas, #drawingCanvas {
            border: 2px solid var(--md-sys-color-outline); /* Subtle border */
            display: block;
            /* Width and Height will be set explicitly in JS to img.naturalWidth/Height */
        }
        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            background-color: transparent;
        }
        #annotationTools {
            position: absolute; /* Position absolutely to float above content */
            bottom: 20px; /* Distance from bottom of the overlay */
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            width: 90%; /* Take up most of the width */
            max-width: 850px; /* Limit width on larger screens */
            display: flex;
            gap: 8px; /* Adjusted gap */
            /* Removed background, padding, border-radius, and box-shadow */
            /* background-color: var(--md-sys-color-surface-variant); */
            /* padding: 15px; */
            /* border-radius: 12px; */
            /* box-shadow: 0 0 15px rgba(0,0,0,0.3); */
            flex-wrap: nowrap; /* Forces content to stay on one row */
            justify-content: center;
            align-items: center; /* Ensure vertical alignment */
            z-index: 10000; /* Ensure it's above everything else */
            overflow-x: auto; /* Allow horizontal scrolling if content overflows */
        }
        #annotationTools button {
            padding: 8px 12px; /* Adjusted padding */
            font-size: 0.85em; /* Adjusted font size */
            border-radius: 16px; /* Smaller rounded corners for tool buttons */
            background-color: var(--md-sys-color-secondary); /* Secondary color for annotation tools */
            color: var(--md-sys-color-on-secondary);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            flex-shrink: 0; /* Prevent buttons from shrinking */
        }
        #annotationTools button:hover {
            background-color: color-mix(in srgb, var(--md-sys-color-secondary) 85%, black);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        }
        #annotationTools button:active {
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            transform: translateY(1px);
        }

        /* Active tool button style within annotation tools */
        #annotationTools button.active-tool {
            background-color: var(--md-sys-color-primary); /* Primary color for active tool */
            outline: none; /* Remove default outline */
        }
        #annotationTools button.active-tool:hover {
            background-color: color-mix(in srgb, var(--md-sys-color-primary) 85%, black);
        }

        /* Main Color Picker Circle */
        #mainColorPickerCircle {
            width: 38px; /* Slightly larger for main button */
            height: 38px;
            border-radius: 50%;
            border: 3px solid var(--md-sys-color-outline);
            cursor: pointer;
            transition: border-color 0.2s ease; /* Removed transform from transition */
            flex-shrink: 0;
            background-color: black; /* Initial color */
            display: flex; /* Added for centering icon */
            align-items: center; /* Added for centering icon */
            justify-content: center; /* Added for centering icon */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Original shadow */
        }
        #mainColorPickerCircle:hover {
            transform: none; /* Explicitly ensure no transform on hover */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); /* Original hover shadow */
        }
        #mainColorPickerCircle .material-symbols-outlined {
            color: var(--md-sys-color-on-tertiary); /* Color for the icon */
            font-size: 1.5em; /* Make the icon slightly larger */
        }

        /* Individual color pickers within the new panel */
        .color-picker {
            width: 32px; /* Adjusted size */
            height: 32px; /* Adjusted size */
            border-radius: 50%;
            border: 3px solid var(--md-sys-color-outline); /* Thicker border */
            cursor: pointer;
            transition: transform 0.2s ease, border-color 0.2s ease;
            flex-shrink: 0; /* Prevent from shrinking */
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); /* Original shadow */
        }
        .color-picker:hover {
            transform: none; /* Removed scaling on hover */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15); /* Original hover shadow */
        }
        .color-picker.active-color {
            border-color: var(--md-sys-color-primary); /* Use primary color for active */
            transform: none; /* Removed scaling on active */
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2); /* Original active shadow */
        }

        /* Style for Material Symbols icon */
        .material-symbols-outlined {
          font-variation-settings:
          'FILL' 0,
          'wght' 400,
          'GRAD' 0,
          'opsz' 24;
          font-size: 1em; /* Adjusted to scale with parent font size */
        }
        button .material-symbols-outlined {
            color: inherit; /* Ensure icon inherits button's text color */
        }

        /* Styles for the new slider */
        #brushSizeControlGroup { /* New container for slider and display */
            display: flex;
            align-items: center;
            gap: 4px; /* Reduced gap to bring text closer */
            margin: 0 5px; /* Add some horizontal margin to the group */
            color: var(--md-sys-color-on-surface); /* Ensure text color is visible */
            font-size: 0.8em; /* Adjusted font size for slider labels */
            font-weight: 400; /* Normal weight for labels */
            flex-shrink: 0; /* Prevent from shrinking */
        }
        #brushSizeControlGroup span {
            white-space: nowrap; /* Prevent text from wrapping */
        }

        #brushSizeSlider {
            -webkit-appearance: none; /* Override default look */
            width: 120px; /* Adjusted width for the slider */
            height: 8px; /* Thickness of the slider track */
            background: var(--md-sys-color-secondary-container); /* Track color */
            border-radius: 4px;
            outline: none;
            transition: background 0.2s;
        }

        /* Slider thumb */
        #brushSizeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px; /* Adjusted size of the thumb */
            height: 20px; /* Adjusted size of the thumb */
            background: var(--md-sys-color-primary); /* Thumb color */
            border-radius: 50%; /* Circular thumb */
            cursor: grab;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background 0.2s, box-shadow 0.2s;
            margin-top: -6px; /* Center thumb vertically on track */
        }

        #brushSizeSlider::-webkit-slider-thumb:hover {
            background: color-mix(in srgb, var(--md-sys-color-primary) 85%, black);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
        }

        #brushSizeSlider::-webkit-slider-thumb:active {
            cursor: grabbing;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        #brushSizeSlider::-moz-range-thumb {
            width: 20px; /* Adjusted size of the thumb */
            height: 20px; /* Adjusted size of the thumb */
            background: var(--md-sys-color-primary);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background 0.2s, box-shadow 0.2s;
        }

        #brushSizeSlider::-moz-range-thumb:hover {
            background: color-mix(in srgb, var(--md-sys-color-primary) 85%, black);
            box-shadow: 0 44px 8px rgba(0, 0, 0, 0.25);
        }
        #brushSizeSlider::-moz-range-thumb:active {
            cursor: grabbing;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        /* New Color/Size Selection Panel */
        #colorSizeSelectionPanel {
            position: absolute;
            /* Positioning will be handled by JS */
            background-color: var(--md-sys-color-surface);
            padding: 15px; /* Slightly reduced padding */
            border-radius: 16px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25); /* Added shadow to panel */
            z-index: 10001; /* Above annotationTools */
            display: flex;
            flex-direction: column;
            gap: 12px; /* Slightly reduced gap */
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping within the panel */
            max-width: 90vw; /* Responsive width */
            max-height: 90vh; /* Responsive height */
            overflow-y: auto; /* Scroll if content overflows */
        }
        #colorSizeSelectionPanel.hidden {
            display: none;
        }
        #colorSelectionGroup {
            display: flex;
            gap: 8px; /* Adjusted gap */
            flex-wrap: wrap;
            justify-content: center;
        }
        #colorSizeSelectionPanel .panel-button { /* General style for buttons within the panel */
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            padding: 8px 12px; /* Adjusted padding */
            border-radius: 16px; /* Match other small buttons */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 0.85em; /* Match other small buttons */
            display: flex; /* To center icon */
            align-items: center;
            justify-content: center;
            gap: 4px;
        }
        #colorSizeSelectionPanel .panel-button:hover {
            background-color: color-mix(in srgb, var(--md-sys-color-primary) 85%, black);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        }
        #colorSizeSelectionPanel .panel-button.active-tool {
            outline: 2px solid var(--md-sys-color-on-surface); /* More subtle active state for tool buttons in panel */
            outline-offset: 2px;
        }
        #eraserToolBtn { /* Specific styling for eraser button in panel */
            background-color: var(--md-sys-color-tertiary); /* Different color for eraser to distinguish */
            color: var(--md-sys-color-on-tertiary);
            padding: 8px 12px; /* Match other panel buttons */
            font-size: 0.85em;
            border-radius: 16px;
        }
        #eraserToolBtn:hover {
            background-color: color-mix(in srgb, var(--md-sys-color-tertiary) 85%, black);
        }
        #eraserToolBtn.active-tool {
            background-color: var(--md-sys-color-error); /* Red when active to signify delete */
        }
        #eraserToolBtn.active-tool:hover {
            background-color: color-mix(in srgb, var(--md-sys-color-error) 85%, black);
        }

    </style>
</head>
<body>
    <div id="info">
        Click 'Add Mode' to add cubes. Click 'Remove Mode' to remove cubes. <br>
        In 'Add Mode', click on a face of a cube or the grid to add a new cube. <br>
        In 'Remove Mode', click on a cube to remove it. <br>
        Use **right-click** (or **one-finger drag on touch**) to orbit, scroll (or **two-finger pinch on touch**) to zoom.
    </div>
    <div id="controls">
        <button id="addModeBtn" class="active">Add Mode</button>
        <button id="removeModeBtn" class="remove">Remove Mode</button>
        <button id="annotateBtn" class="annotate-btn">Annotate</button>
        <button id="toggleInfoBtn" class="toggle-info">Hide Instructions</button>
    </div>

    <!-- Annotation Overlay -->
    <div id="annotationOverlay" class="hidden">
        <div id="canvasContainer">
            <canvas id="screenshotCanvas"></canvas>
            <canvas id="drawingCanvas"></canvas>
        </div>
        <!-- Annotation Tools are now placed ABSOLUTELY and on top -->
        <div id="annotationTools">
            <!-- Main Color Picker Circle -->
            <div id="mainColorPickerCircle" class="color-picker"></div>

            <!-- Undo/Redo Buttons -->
            <button id="undoAnnotationBtn">
                <span class="material-symbols-outlined">undo</span>
                Undo
            </button>
            <button id="redoAnnotationBtn">
                <span class="material-symbols-outlined">redo</span>
                Redo
            </button>

            <!-- Action Buttons -->
            <button id="clearAnnotationBtn">
                <span class="material-symbols-outlined">delete</span>
                Clear
            </button>
            <button id="saveAnnotationBtn">
                <span class="material-symbols-outlined">save</span>
                Save Annotation
            </button>
            <button id="closeAnnotationBtn">
                <span class="material-symbols-outlined">close</span>
                Close
            </button>
        </div>

        <!-- New Color and Size Selection Panel (Hidden by default) -->
        <div id="colorSizeSelectionPanel" class="hidden">
            <div id="colorSelectionGroup">
                <div class="color-picker" style="background-color: red;" data-color="red"></div>
                <div class="color-picker" style="background-color: green;" data-color="green"></div>
                <div class="color-picker" style="background-color: blue;" data-color="blue"></div>
                <div class="color-picker" style="background-color: black;" data-color="black"></div>
                <!-- Add more colors as needed -->
            </div>

            <!-- Brush Size Controls (Slider) -->
            <div id="brushSizeControlGroup">
                <span>Min (1)</span>
                <input type="range" id="brushSizeSlider" min="1" max="30" value="5" step="1">
                <span>Max (30)</span>
            </div>

            <!-- Eraser Button - now inside the panel and icon-only -->
            <button id="eraserToolBtn" class="panel-button">
                <span class="material-symbols-outlined">auto_fix_normal</span>
            </button>

            <!-- Close button removed as per request, auto-close handles dismissal -->
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let cubes = new Map();
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let currentMode = 'add';
        let edgeLinesGroup;

        const GRID_SIZE = 10;
        const CUBE_SIZE = 1;
        const HALF_CUBE_SIZE = CUBE_SIZE / 2;

        const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x0077ff, opacity: 1, transparent: false });
        const highlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
        const ghostMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.5 });
        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });

        let intersectedObject = null;
        let ghostCube = null;
        let lastClickPosition = new THREE.Vector3(Infinity, Infinity, Infinity);

        // Annotation variables
        let screenshotCanvas, screenshotCtx;
        let drawingCanvas, drawingCtx;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentColor = 'black';
        let brushSize = 5;
        let activeTool = 'color'; // 'color' or 'eraser'

        // History for undo/redo
        let drawingHistory = [];
        let redoStack = [];
        let currentStroke = null;

        // Touch interaction variables for 3D scene
        let touchStartX = 0;
        let touchStartY = 0;
        const TAP_THRESHOLD = 10; // Pixels

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xddeeff);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 100;
            controls.maxPolarAngle = Math.PI / 2;
            controls.zoomSpeed = 0.2; // Reduced zoom sensitivity

            controls.mouseButtons = {
                LEFT: THREE.MOUSE.NONE,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.ROTATE
            };
            controls.enablePan = false;

            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -GRID_SIZE;
            directionalLight.shadow.camera.right = GRID_SIZE;
            directionalLight.shadow.camera.top = GRID_SIZE;
            directionalLight.shadow.camera.bottom = -GRID_SIZE;
            scene.add(directionalLight);

            const planeGeometry = new THREE.PlaneGeometry(GRID_SIZE * 2, GRID_SIZE * 2);
            const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = Math.PI / 2;
            plane.position.y = -HALF_CUBE_SIZE;
            plane.receiveShadow = true;
            plane.name = 'groundPlane';
            scene.add(plane);

            ghostCube = new THREE.Mesh(new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE), ghostMaterial);
            ghostCube.visible = false;
            ghostCube.name = 'ghostCube';
            scene.add(ghostCube);

            edgeLinesGroup = new THREE.Group();
            edgeLinesGroup.name = 'edgeLinesGroup';
            scene.add(edgeLinesGroup);

            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('click', onCanvasClick, false);
            renderer.domElement.addEventListener('touchstart', onCanvasTouchStart, false); // Added touchstart listener
            renderer.domElement.addEventListener('touchend', onCanvasTouchEnd, false);     // Added touchend listener

            document.getElementById('addModeBtn').addEventListener('click', () => setMode('add'));
            document.getElementById('removeModeBtn').addEventListener('click', () => setMode('remove'));
            document.getElementById('toggleInfoBtn').addEventListener('click', toggleInstructions);
            document.getElementById('annotateBtn').addEventListener('click', captureAndAnnotate);

            // Hide instructions by default on app start
            document.getElementById('info').classList.add('hidden');
            document.getElementById('toggleInfoBtn').textContent = 'Show Instructions';

            setMode(currentMode);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function toggleInstructions() {
            const infoDiv = document.getElementById('info');
            if (infoDiv.classList.contains('hidden')) {
                infoDiv.classList.remove('hidden');
                document.getElementById('toggleInfoBtn').textContent = 'Hide Instructions';
            } else {
                infoDiv.classList.add('hidden');
                document.getElementById('toggleInfoBtn').textContent = 'Show Instructions';
            }
        }

        function setMode(mode) {
            currentMode = mode;
            document.getElementById('addModeBtn').classList.remove('active');
            document.getElementById('removeModeBtn').classList.remove('active');
            document.getElementById(`${mode}ModeBtn`).classList.add('active');

            if (intersectedObject && intersectedObject.name === 'unitCube') {
                intersectedObject.material = baseMaterial.clone();
            }
            intersectedObject = null;

            if (ghostCube) {
                ghostCube.visible = (currentMode === 'add');
            }
            lastClickPosition.set(Infinity, Infinity, Infinity);
        }

        function addCube(x, y, z) {
            x = Math.round(x);
            y = Math.round(y);
            z = Math.round(z);

            const key = `${x},${y},${z}`;
            if (cubes.has(key)) {
                return;
            }

            const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
            const cubeMesh = new THREE.Mesh(geometry, baseMaterial.clone());
            cubeMesh.position.set(x, y, z);
            cubeMesh.castShadow = true;
            cubeMesh.receiveShadow = true;
            cubeMesh.name = 'unitCube';

            const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geometry), edgeMaterial);
            edges.position.copy(cubeMesh.position);
            edges.name = `edges_${key}`;
            edgeLinesGroup.add(edges);

            scene.add(cubeMesh);
            cubes.set(key, { mesh: cubeMesh, edges: edges });
        }

        function removeCube(x, y, z) {
            const key = `${x},${y},${z}`;
            if (cubes.has(key)) {
                const cubeData = cubes.get(key);
                const cubeMeshToRemove = cubeData.mesh;
                const edgeLinesToRemove = cubeData.edges;

                scene.remove(cubeMeshToRemove);
                edgeLinesGroup.remove(edgeLinesToRemove);

                cubes.delete(key);

                cubeMeshToRemove.geometry.dispose();
                if (cubeMeshToRemove.material.dispose) {
                    cubeMeshToRemove.material.dispose();
                }
                edgeLinesToRemove.geometry.dispose();
                if (edgeLinesToRemove.material.dispose) {
                    edgeLinesToRemove.material.dispose();
                }

                if (intersectedObject === cubeMeshToRemove) {
                    intersectedObject = null;
                }
            }
        }

        function onMouseMove(event) {
            event.preventDefault();

            // If annotation overlay is visible, prevent 3D scene interactions
            if (!document.getElementById('annotationOverlay').classList.contains('hidden')) {
                return;
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const objectsToIntersect = Array.from(cubes.values()).map(data => data.mesh);
            const groundPlane = scene.getObjectByName('groundPlane');
            if (groundPlane) {
                objectsToIntersect.push(groundPlane);
            }

            const intersects = raycaster.intersectObjects(objectsToIntersect, true);

            if (currentMode === 'remove') {
                if (intersects.length > 0 && intersects[0].object.name === 'unitCube') {
                    const intersect = intersects[0];
                    if (intersect.object !== intersectedObject) {
                        if (intersectedObject && intersectedObject.name === 'unitCube') {
                            intersectedObject.material = baseMaterial.clone();
                        }
                        intersectedObject = intersect.object;
                        intersectedObject.material = highlightMaterial;
                    }
                } else {
                    if (intersectedObject && intersectedObject.name === 'unitCube') {
                        intersectedObject.material = baseMaterial.clone();
                    }
                    intersectedObject = null;
                }
            } else {
                 if (intersectedObject && intersectedObject.name === 'unitCube') {
                    intersectedObject.material = baseMaterial.clone();
                }
                intersectedObject = null;
            }

            if (currentMode === 'add') {
                if (intersects.length > 0) {
                    const intersect = intersects[0];

                    if (intersect.face && (intersect.object.name === 'unitCube' || intersect.object.name === 'groundPlane')) {
                        let ghostX, ghostY, ghostZ;

                        if (intersect.object.name === 'unitCube') {
                            ghostX = intersect.object.position.x + intersect.face.normal.x * CUBE_SIZE;
                            ghostY = intersect.object.position.y + intersect.face.normal.y * CUBE_SIZE;
                            ghostZ = intersect.object.position.z + intersect.face.normal.z * CUBE_SIZE;
                        } else if (intersect.object.name === 'groundPlane') {
                            ghostX = Math.round(intersect.point.x / CUBE_SIZE) * CUBE_SIZE;
                            ghostY = 0;
                            ghostZ = Math.round(intersect.point.z / CUBE_SIZE) * CUBE_SIZE;
                        }

                        ghostX = Math.round(ghostX);
                        ghostY = Math.round(ghostY);
                        ghostZ = Math.round(ghostZ);

                        if (!cubes.has(`${ghostX},${ghostY},${ghostZ}`)) {
                            ghostCube.position.set(ghostX, ghostY, ghostZ);
                            ghostCube.visible = true;
                        } else {
                            ghostCube.visible = false;
                        }
                    } else {
                        ghostCube.visible = false;
                    }
                } else {
                    ghostCube.visible = false;
                }
            } else {
                ghostCube.visible = false;
            }
        }

        // Shared function to handle cube interaction logic for both mouse and touch
        function handleCubeInteraction(currentMouse) {
            raycaster.setFromCamera(currentMouse, camera);

            const objectsToIntersect = Array.from(cubes.values()).map(data => data.mesh);
            const groundPlane = scene.getObjectByName('groundPlane');
            if (groundPlane) {
                objectsToIntersect.push(groundPlane);
            }

            const intersects = raycaster.intersectObjects(objectsToIntersect, true);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const clickedObject = intersect.object;

                if (intersect.face && (clickedObject.name === 'unitCube' || clickedObject.name === 'groundPlane')) {
                    if (currentMode === 'add') {
                        let newCubeX, newCubeY, newCubeZ;

                        if (clickedObject.name === 'unitCube') {
                            newCubeX = clickedObject.position.x + intersect.face.normal.x * CUBE_SIZE;
                            newCubeY = clickedObject.position.y + intersect.face.normal.y * CUBE_SIZE;
                            newCubeZ = clickedObject.position.z + intersect.face.normal.z * CUBE_SIZE;
                        } else if (clickedObject.name === 'groundPlane') {
                            newCubeX = Math.round(intersect.point.x / CUBE_SIZE) * CUBE_SIZE;
                            newCubeY = 0;
                            newCubeZ = Math.round(intersect.point.z / CUBE_SIZE) * CUBE_SIZE;
                        }

                        newCubeX = Math.round(newCubeX);
                        newCubeY = Math.round(newCubeY);
                        newCubeZ = Math.round(newCubeZ);

                        const currentSnappedPosition = new THREE.Vector3(newCubeX, newCubeY, newCubeZ);

                        if (lastClickPosition.equals(currentSnappedPosition)) {
                            return;
                        }

                        addCube(newCubeX, newCubeY, newCubeZ);
                        lastClickPosition.copy(currentSnappedPosition);

                    } else if (currentMode === 'remove') {
                        if (clickedObject.name === 'unitCube') {
                            removeCube(clickedObject.position.x, clickedObject.position.y, clickedObject.position.z);
                            lastClickPosition.set(Infinity, Infinity, Infinity);
                        }
                    }
                }
            } else {
                lastClickPosition.set(Infinity, Infinity, Infinity);
            }
        }

        function onCanvasClick(event) {
            event.preventDefault();

            // If annotation overlay is visible, prevent 3D scene interactions
            if (!document.getElementById('annotationOverlay').classList.contains('hidden')) {
                return;
            }

            if (event.button !== 0) { // Only left click for mouse
                return;
            }

            // Important: Check if OrbitControls is currently active (meaning a mouse drag/orbit happened).
            // This prevents adding a cube if the user just finished dragging the camera with the left mouse button.
            if (controls.enabled && controls.state !== THREE.MOUSE.NONE) {
                // No controls.reset() here, as it might interfere with subsequent actions.
                // The check itself is enough to prevent interaction during a drag.
                return;
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            handleCubeInteraction(mouse);
        }

        // New function for touch start
        function onCanvasTouchStart(event) {
            if (!document.getElementById('annotationOverlay').classList.contains('hidden')) {
                return; // Don't interfere if annotation mode is active
            }
            if (event.touches.length === 1) { // Only track single finger tap for interaction
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            }
        }

        // New function for touch end
        function onCanvasTouchEnd(event) {
            event.preventDefault(); // Prevent default browser actions like scrolling

            if (!document.getElementById('annotationOverlay').classList.contains('hidden')) {
                return; // Don't interfere if annotation mode is active
            }

            if (event.changedTouches.length === 1) { // Only consider single finger lift
                const touch = event.changedTouches[0];
                const touchEndX = touch.clientX;
                const touchEndY = touch.clientY;

                const distance = Math.sqrt(
                    Math.pow(touchEndX - touchStartX, 2) +
                    Math.pow(touchEndY - touchStartY, 2)
                );

                if (distance < TAP_THRESHOLD) { // If it's a tap (minimal movement)
                    mouse.x = (touchEndX / window.innerWidth) * 2 - 1;
                    mouse.y = -(touchEndY / window.innerHeight) * 2 + 1;
                    handleCubeInteraction(mouse);
                }
            }
        }


        // Annotation Functions
        function setupAnnotationCanvas() {
            // Get both canvas elements and their contexts
            screenshotCanvas = document.getElementById('screenshotCanvas');
            screenshotCtx = screenshotCanvas.getContext('2d', { alpha: true }); // Explicitly request alpha
            drawingCanvas = document.getElementById('drawingCanvas');
            drawingCtx = drawingCanvas.getContext('2d', { alpha: true }); // Explicitly request alpha

            const annotationOverlay = document.getElementById('annotationOverlay');
            const canvasContainer = document.getElementById('canvasContainer');
            const brushSizeSlider = document.getElementById('brushSizeSlider');
            const mainColorPickerCircle = document.getElementById('mainColorPickerCircle');
            const colorSizeSelectionPanel = document.getElementById('colorSizeSelectionPanel');
            const eraserToolBtn = document.getElementById('eraserToolBtn');


            // IMPORTANT: Render the scene just before capturing the screenshot
            renderer.render(scene, camera);
            const screenshot = renderer.domElement.toDataURL('image/png');
            const img = new Image();
            img.onload = () => {
                // Set both canvases internal resolution to match the screenshot resolution
                screenshotCanvas.width = img.naturalWidth; // Use naturalWidth/Height for direct pixel match
                screenshotCanvas.height = img.naturalHeight;
                drawingCanvas.width = img.naturalWidth;
                drawingCanvas.height = img.naturalHeight;

                // Set canvasContainer's dimensions to maintain original image size
                // This might make the canvas larger than the viewport, enabling scrolling
                canvasContainer.style.width = `${img.naturalWidth}px`;
                canvasContainer.style.height = `${img.naturalHeight}px`;

                // Draw the screenshot onto the screenshotCanvas (background layer)
                screenshotCtx.clearRect(0, 0, screenshotCanvas.width, screenshotCanvas.height); // Clear any previous content
                screenshotCtx.drawImage(img, 0, 0);

                // Clear the drawing canvas to ensure it's transparent for new annotations
                redrawCanvas(); // Redraw initial empty state

                // Set initial active tool to black color and update main color picker
                setActiveTool('color', 'black');
                // mainColorPickerCircle.style.backgroundColor = 'black'; // This is now handled by setActiveTool
                // mainColorPickerCircle.innerHTML = ''; // This is now handled by setActiveTool

                // Initialize slider value
                brushSizeSlider.value = brushSize; // Set slider to current brushSize
            };
            img.src = screenshot;

            // Show the annotation overlay by setting its display style
            annotationOverlay.style.display = 'flex';
            annotationOverlay.classList.remove('hidden');
            // Hide the color/size selection panel initially
            colorSizeSelectionPanel.classList.add('hidden');

            // Disable OrbitControls while annotating
            controls.enabled = false;

            // Set up drawing event listeners for the 2D canvas (drawingCanvas)
            drawingCanvas.addEventListener('mousedown', startDrawing);
            drawingCanvas.addEventListener('mousemove', draw);
            drawingCanvas.addEventListener('mouseup', stopDrawing);
            drawingCanvas.addEventListener('mouseout', stopDrawing);

            // Touch events for drawing
            drawingCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                startDrawing({ clientX: touch.clientX, clientY: touch.clientY });
            });
            drawingCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                draw({ clientX: touch.clientX, clientY: touch.clientY });
            });
            drawingCanvas.addEventListener('touchend', stopDrawing);
            drawingCanvas.addEventListener('touchcancel', stopDrawing);


            // Setup annotation tool buttons
            mainColorPickerCircle.removeEventListener('click', toggleColorSizePanel);
            mainColorPickerCircle.addEventListener('click', toggleColorSizePanel);
            mainColorPickerCircle.addEventListener('mousedown', (e) => e.stopPropagation()); // Prevent global click from closing

            document.querySelectorAll('#colorSizeSelectionPanel .color-picker').forEach(picker => {
                picker.removeEventListener('click', selectColor);
                picker.addEventListener('click', selectColor);
            });
            // Eraser button inside the panel
            eraserToolBtn.removeEventListener('click', activateEraser);
            eraserToolBtn.addEventListener('click', activateEraser);


            document.getElementById('clearAnnotationBtn').removeEventListener('click', clearDrawing);
            document.getElementById('clearAnnotationBtn').addEventListener('click', clearDrawing);
            document.getElementById('saveAnnotationBtn').removeEventListener('click', saveAnnotation);
            document.getElementById('saveAnnotationBtn').addEventListener('click', saveAnnotation);
            document.getElementById('closeAnnotationBtn').removeEventListener('click', closeAnnotation);
            document.getElementById('closeAnnotationBtn').addEventListener('click', closeAnnotation);

            document.getElementById('undoAnnotationBtn').removeEventListener('click', undoAnnotation);
            document.getElementById('undoAnnotationBtn').addEventListener('click', undoAnnotation);
            document.getElementById('redoAnnotationBtn').removeEventListener('click', redoAnnotation);
            document.getElementById('redoAnnotationBtn').addEventListener('click', redoAnnotation);


            // Slider event listener
            brushSizeSlider.removeEventListener('input', updateBrushSizeFromSlider); // Prevent duplicate listeners
            brushSizeSlider.addEventListener('input', updateBrushSizeFromSlider);

            // Global click listener for auto-closing the panel
            document.removeEventListener('mousedown', handleGlobalClick); // Prevent duplicates
            document.addEventListener('mousedown', handleGlobalClick);

            // Stop propagation for the panel itself to prevent closing when interacting with its elements
            colorSizeSelectionPanel.addEventListener('mousedown', (e) => e.stopPropagation());
        }

        function handleGlobalClick(event) {
            const colorSizeSelectionPanel = document.getElementById('colorSizeSelectionPanel');
            const mainColorPickerCircle = document.getElementById('mainColorPickerCircle');

            // If the panel is visible and the click is outside both the panel and the main color picker
            if (!colorSizeSelectionPanel.classList.contains('hidden') &&
                !colorSizeSelectionPanel.contains(event.target) &&
                !mainColorPickerCircle.contains(event.target)) {
                closeColorSizePanel();
            }
        }


        function toggleColorSizePanel(event) {
            event.stopPropagation(); // Prevent immediate closing by global listener
            const panel = document.getElementById('colorSizeSelectionPanel');
            const mainCircle = document.getElementById('mainColorPickerCircle');

            if (panel.classList.contains('hidden')) {
                // Show the panel
                panel.classList.remove('hidden');

                // Position the panel above the mainCircle
                const mainCircleRect = mainCircle.getBoundingClientRect();
                // Get panel dimensions *after* it's visible, otherwise its rect might be 0
                const panelRect = panel.getBoundingClientRect();

                // Calculate bottom position: mainCircle's top edge - panel's height - a small margin
                let bottomPosition = (window.innerHeight - mainCircleRect.top) + 10; // 10px margin from main circle top

                // Calculate left position: center the panel relative to the mainCircle
                let leftPosition = mainCircleRect.left + (mainCircleRect.width / 2) - (panelRect.width / 2);

                // Ensure panel stays within viewport horizontally
                if (leftPosition < 10) leftPosition = 10; // 10px from left edge
                if (leftPosition + panelRect.width > window.innerWidth - 10) {
                    leftPosition = window.innerWidth - panelRect.width - 10; // 10px from right edge
                }

                panel.style.bottom = `${bottomPosition}px`;
                panel.style.left = `${leftPosition}px`;


                // Ensure the correct color picker is active when the panel opens
                document.querySelectorAll('#colorSizeSelectionPanel .color-picker').forEach(picker => {
                    picker.classList.remove('active-color');
                    if (picker.dataset.color === currentColor) {
                        picker.classList.add('active-color');
                    }
                });

                // Set initial active state for eraser button when panel opens
                document.getElementById('eraserToolBtn').classList.remove('active-tool');
                if (activeTool === 'eraser') {
                    document.getElementById('eraserToolBtn').classList.add('active-tool');
                }
                // No need for 'color' else-if here, setActiveTool handles main color picker's state
            } else {
                // Hide the panel
                panel.classList.add('hidden');
            }
        }

        function closeColorSizePanel() {
            document.getElementById('colorSizeSelectionPanel').classList.add('hidden');
        }

        function updateBrushSizeFromSlider(event) {
            brushSize = parseInt(event.target.value);
        }

        // Function to manage active tool and canvas context properties
        function setActiveTool(toolType, color = null) {
            const mainColorPickerCircle = document.getElementById('mainColorPickerCircle');
            const eraserToolBtn = document.getElementById('eraserToolBtn');

            // Reset all active states in the pop-up panel
            document.querySelectorAll('#colorSizeSelectionPanel .color-picker').forEach(picker => {
                picker.classList.remove('active-color');
            });
            eraserToolBtn.classList.remove('active-tool'); // Remove active from eraser button in panel

            // Clear previous state of mainColorPickerCircle
            mainColorPickerCircle.innerHTML = ''; // Remove any existing icon
            mainColorPickerCircle.style.backgroundColor = ''; // Clear background color
            mainColorPickerCircle.style.borderColor = 'var(--md-sys-color-outline)'; // Reset border

            if (toolType === 'color') {
                currentColor = color;
                const selectedPicker = document.querySelector(`#colorSizeSelectionPanel .color-picker[data-color="${color}"]`);
                if (selectedPicker) {
                    selectedPicker.classList.add('active-color');
                }
                mainColorPickerCircle.style.backgroundColor = currentColor;
                activeTool = 'color';
            } else if (toolType === 'eraser') {
                eraserToolBtn.classList.add('active-tool');
                mainColorPickerCircle.innerHTML = '<span class="material-symbols-outlined">auto_fix_normal</span>';
                mainColorPickerCircle.style.borderColor = 'var(--md-sys-color-tertiary)'; // Change border to match eraser style
                activeTool = 'eraser';
            }
        }

        // Function to redraw all strokes from history
        function redrawCanvas() {
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            drawingHistory.forEach(stroke => {
                // To redraw, we need to respect the original drawing parameters
                drawingCtx.beginPath();
                drawingCtx.moveTo(stroke.path[0].x, stroke.path[0].y);
                for (let i = 1; i < stroke.path.length; i++) {
                    drawingCtx.lineTo(stroke.path[i].x, stroke.path[i].y);
                }
                drawingCtx.lineWidth = stroke.brushSize;
                drawingCtx.lineCap = 'round';
                drawingCtx.lineJoin = 'round';

                // Handle eraser strokes correctly during redraw
                if (stroke.isEraser) {
                    drawingCtx.globalCompositeOperation = 'destination-out';
                    drawingCtx.strokeStyle = 'rgba(0,0,0,1)'; // Opaque for destination-out
                } else {
                    drawingCtx.globalCompositeOperation = 'source-over';
                    drawingCtx.strokeStyle = stroke.color;
                }
                drawingCtx.stroke();
            });
             // Reset to default drawing mode after redrawing all history elements
            drawingCtx.globalCompositeOperation = 'source-over';
        }


        function startDrawing(e) {
            isDrawing = true;
            const rect = drawingCanvas.getBoundingClientRect();
            // Scale mouse coordinates to canvas internal resolution
            lastX = (e.clientX - rect.left) * (drawingCanvas.width / rect.width);
            lastY = (e.clientY - rect.top) * (drawingCanvas.height / rect.height);

            currentStroke = {
                color: currentColor,
                brushSize: brushSize,
                isEraser: (activeTool === 'eraser'),
                path: [{ x: lastX, y: lastY }]
            };
            // Clear redoStack on new drawing action
            redoStack = [];
        }

        function draw(e) {
            if (!isDrawing) return;
            const rect = drawingCanvas.getBoundingClientRect();
            // Scale mouse coordinates to canvas internal resolution
            const currentX = (e.clientX - rect.left) * (drawingCanvas.width / rect.width);
            const currentY = (e.clientY - rect.top) * (drawingCanvas.height / rect.height);

            currentStroke.path.push({ x: currentX, y: currentY });

            // Temporarily set drawing styles for real-time preview
            drawingCtx.beginPath();
            drawingCtx.moveTo(lastX, lastY);
            drawingCtx.lineTo(currentX, currentY);

            drawingCtx.lineWidth = brushSize;
            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';

            if (activeTool === 'eraser') {
                drawingCtx.globalCompositeOperation = 'destination-out';
                drawingCtx.strokeStyle = 'rgba(0,0,0,1)'; // The color doesn't matter, only its opacity for destination-out
            } else { // 'color' tool
                drawingCtx.globalCompositeOperation = 'source-over';
                drawingCtx.strokeStyle = currentColor;
            }

            drawingCtx.stroke();

            lastX = currentX;
            lastY = currentY;
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            if (currentStroke && currentStroke.path.length > 1) { // Only add if path has actual drawing
                drawingHistory.push(currentStroke);
            }
            currentStroke = null;
            // Redraw everything to ensure proper compositing after a stroke,
            // especially important when switching between drawing and erasing.
            redrawCanvas();
        }

        function selectColor(e) {
            e.stopPropagation(); // Prevent closing by global listener
            // This function is called for color pickers inside the colorSizeSelectionPanel
            setActiveTool('color', e.target.dataset.color);
            // Optionally close the panel after selecting a color
            // closeColorSizePanel(); // Keeping this commented, per conversation history, to allow continuous changes.
        }

        function activateEraser(e) {
            e.stopPropagation(); // Prevent closing by global listener
            setActiveTool('eraser');
        }

        function clearDrawing() {
            // Store the current drawingHistory as a 'clear' action
            if (drawingHistory.length > 0) {
                redoStack.push({ type: 'clear', history: [...drawingHistory] });
                drawingHistory = [];
                redrawCanvas();
            }
        }

        function undoAnnotation() {
            if (drawingHistory.length > 0) {
                const undoneStroke = drawingHistory.pop();
                redoStack.push(undoneStroke);
                redrawCanvas();
            } else if (redoStack.length > 0 && redoStack[redoStack.length - 1].type === 'clear') {
                // If the last action in redoStack was a 'clear', undo it
                const clearAction = redoStack.pop();
                drawingHistory = clearAction.history;
                redrawCanvas();
            }
        }

        function redoAnnotation() {
            if (redoStack.length > 0) {
                const redoneAction = redoStack.pop();
                if (redoneAction.type === 'clear') {
                    // If redoing a 'clear', clear the current history and store it for undoing a redo of clear
                    drawingHistory = [];
                    // Note: If you want to be able to undo a re-cleared canvas, you'd need to push a new 'clear' action here.
                    // For simplicity, redoing a clear just empties the canvas again without a new undoable clear.
                } else {
                    drawingHistory.push(redoneAction);
                }
                redrawCanvas();
            }
        }


        function saveAnnotation() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d', { alpha: true }); // Ensure alpha for the combined image

            tempCanvas.width = screenshotCanvas.width;
            tempCanvas.height = screenshotCanvas.height;

            // Draw the screenshot first
            tempCtx.drawImage(screenshotCanvas, 0, 0);
            // Then draw the annotations on top (which might have transparent areas due to eraser)
            tempCtx.drawImage(drawingCanvas, 0, 0);

            const dataURL = tempCanvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = 'annotated_cubes.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        function closeAnnotation() {
            const annotationOverlay = document.getElementById('annotationOverlay');
            annotationOverlay.classList.add('hidden');
            annotationOverlay.style.display = 'none';
            controls.enabled = true;
            // Clear history when closing annotation to start fresh next time
            drawingHistory = [];
            redoStack = [];
            closeColorSizePanel(); // Ensure the pop-up panel is also closed
        }

        function captureAndAnnotate() {
            setupAnnotationCanvas();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (controls.enabled) {
                controls.update();
            }
            renderer.render(scene, camera);
        }

        // Initialize and start animation when window loads
        window.onload = function() {
            init();
            animate();
            addCube(0, 0, 0);
        };
    </script>
</body>
</html>
